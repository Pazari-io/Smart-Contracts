/**
* Contract for consolidating all extensions of ERC20 contract and assigning
* modifiers which permit extended functions only if the user checked
* true upon contract deployment. This allows for customization at the time
* of contract creation without having to migrate and deploy a new contract
* and without having to create and deploy every possible combination of
* contract extensions. However, creating and deploying every possible
* combination would likely be more gas optimized on the users who have
* to use the contracts, since users are likely paying a little extra for
* the extra long bytecode and for the check logic that enables the
* modularity of this contract.
* 
* This contract is cloned by the ContractFactory contract using the user
* input for the constructor. The dapp submits all the bools determining
* which modules are active, which determines the functions that can be 
* used.
* 
* DOWNSIDE: Every function may cost more gas to run due to heavier check logic
*/

pragma solidity ^0.8.0;

import "./Dependencies/ERC20.sol";
import "./Dependencies/Pausable.sol";
import "./Dependencies/ERC20Snapshot.sol";

contract CustomCloneModules is ERC20, ERC20Burnable, ERC20Snapshot {

    // All modules' activation status, bools are set in constructor:
    bool immutable private _burnable; // Enables burn functions;
    bool immutable private _capped; // Enables capped supply;
    uint256 immutable public _cap; // Token cap, if ERC20Capped is active;
    bool immutable private _pausable; // Enables pausing;
    bool immutable private _hasSnapshot; // Enables snapshots;
    bool immutable private _mintable; // Enables minting;

    // Contract pause state;
    bool private _paused; 

    constructor(
    string memory _name,
    string memory _symbol,
    uint256 _amount,
    uint256 cap_,
    bool _burnable,
    bool _capped,
    bool _pausable,
    bool _snapshot,
    bool _mintable)
    ERC20(_name, _symbol) {
        if(_capped) {
            require(cap_ > 0, "ERC20Capped: cap is 0");
            _cap = cap_;
        }

        if(_mintable){
            _mint(msg.sender, _amount);
        }

    }

    // ERC20 BURNABLE

    modifier ifBurnable() {
        require(_burnable, "Burning not supported");
        _;
    }

    function burn(uint256 amount) public virtual override ifBurnable ifPausable {
        _burn(_msgSender(), amount);
    }

    function burnFrom(address account, uint256 amount) public virtual override ifBurnable ifPausable {
        uint256 currentAllowance = allowance(account, _msgSender());
        require(currentAllowance >= amount, "ERC20: burn amount exceeds allowance");
        _approve(account, _msgSender(), currentAllowance - amount);
        _burn(account, amount);
    }    

    // ERC20 CAPPED

    function cap() public view returns (uint256) {
        require(_capped, "Token supply not capped");
        return _cap;
    }

    function _mint(address account, uint256 amount) internal virtual override {
        if(_capped){
            require(ERC20.totalSupply() + amount <= cap(), "ERC20Capped: cap exceeded");
        }
        super._mint(account, amount);
    }

    // ERC20 PAUSABLE
    
    // Checks that user selected pausable at contract creation
    modifier ifPausable() {
        if(_pausable) {
            require(!paused(), "ERC20Pausable: token transfer while paused");
        }
    }

    event Paused(address account);
    event Unpaused(address account);

    function paused() public view virtual returns (bool) {
        return _paused;
    }

    modifier whenNotPaused() {
        require(!paused(), "Pausable: paused");
        _;
    }
    modifier whenPaused() {
        require(paused(), "Pausable: not paused");
        _;
    }
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }


    // _beforeTokenTransfer() function override to include pausing and snapshots;
    function _beforeTokenTransfer(
            address from, 
            address to, 
            uint256 amount) 
        internal 
        virtual 
        override(
            ERC20Pausable, 
            ERC20, 
            ERC20Snapshot) 
            ifPausable {
        super._beforeTokenTransfer(from, to, amount);

        // Snapshot
        if(_hasSnapshot) {
            if (from == address(0)) {
            // mint
                _updateAccountSnapshot(to);
                _updateTotalSupplySnapshot();
            } else if (to == address(0)) {
            // burn
                _updateAccountSnapshot(from);
                _updateTotalSupplySnapshot();
            } else {
            // transfer
                _updateAccountSnapshot(from);
                _updateAccountSnapshot(to);
            }
        }
    }    

}







