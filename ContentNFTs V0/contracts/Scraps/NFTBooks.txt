/**
* WHEN IT IS TIME TO OPTIMIZE FOR GAS, USE THIS ARTICLE FOR IDEAS:
* https://medium.com/@novablitz/storing-structs-is-costing-you-gas-774da988895e
*
* EXPERIMENT WITH THE FOLLOWING FOR GAS EFFICIENCY
*
* uri() and _setURI():
* Replace strings with bytes32 for _setURI(), then run BytesToString
* contract's bytes32ToString() function when calling uri(). This may save gas
* on storage costs for each token's IPFS URI, while still allowing the contract
* to return a string value from the uri() function. Only experiment with this
* after we have established a functional encryption/decryption system.
*
* toggleTrading():
* See if the require() statement consumes gas when it passes, and if it would be
* more gas optimized if we rely on the dapp run this check from the front-end.
* All this check does is make sure the owner can't set isTradable to the same
* value it already possesses, like setting isTradable == true to true.
*
*/

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../Dependencies/IERC1155.sol";
import "../Dependencies/IERC1155Receiver.sol";
import "../Dependencies/IERC1155MetadataURI.sol";
import "../Dependencies/Address.sol";
import "../Dependencies/Context.sol";
import "../Dependencies/ERC165.sol";
import "../Dependencies/Ownable.sol";


/**
 * @dev Modification of the standard ERC1155 token for the purpose-built
 * application of NFT ebooks. Later this contract will be modified to become
 * general-purpose for any kind of token which has hidden content, and won't
 * be limited to ebooks only.
 *
 * Additional optional functionality will be introduced later for authors
 * to choose from when deploying their NFTBooks contract. For now, we will stick
 * with some general functionality that would be very powerful for an author to
 * have control over.
 */
contract NFTBooks is Context, ERC165, IERC1155, IERC1155MetadataURI, Ownable {
    using Address for address;

    // Mapping from ebook ID to account balances
    mapping (uint256 => mapping(address => uint256)) private _balances;

    // Mapping from account to operator approvals
    mapping (address => mapping(address => bool)) private _operatorApprovals;

    // Mapping from ebook ID to metadata's IPFS URI;
    mapping(uint256 => string) private _uri;

    // Mapping from ebook ID to Book struct;
    mapping(uint256 => Book) bookID;

    uint256 private bookIDCounter;

    /**
    * @dev Struct to track smart contract properties of books. 
    * Keep this struct as minimalistic as possible and optimize for gas usage.
    *
    * TO STORE IN OFF-CHAIN METADATA:
    * -Book Title
    * -Book Cover - static image
    * -Book Cover - animated image
    * -Book description
    * -Author
    * -Genre
    * -Publishing Company
    * -Copyright License
    * -Other Credits (i.e. Editor, Co-Author, etc.)
    * -IPFS hash of content (encrypted)
    * -IPFS hash of content preview / sample text (unencrypted)
    */
    struct Book {
        address payable author; // Address where royalties are sent, can be contract;
        uint256 mintPrice; // Price of book in AVAX at time of mint -- introduce fiat values later;
        bool isMintable; // Book can be minted;
        bool isBurnable; // Book can be burned;
        bool isTradable; // Book can be traded;
        uint8 royalty; // Percent of sale that goes back to author, royalty < 100;
    }

    constructor () {
        super;
    }

    /**
     * @dev Checks if token _bookID is mintable or not:
     * True = Standard Edition, can be minted by author
     * False = Special/Limited Edition, cannot be minted by anyone
     */
    modifier _isMintable(uint256 _bookID) {
        require(bookID[_bookID].isMintable == true, "Minting disabled");
        _;
    }

    /**
     * @dev Checks if token _bookID is tradable or not:
     * True = Book can be traded on secondary market.
     * False = Book cannot be traded on secondary market.
     *
     * NFT bookstore market contract is non-custodial, the first owner
     * of every NFT ebook will be the owner of the contract who calls the mint() 
     * function. Non-tradable books can be transferred from author to reader, 
     * but not between readers.
     */
    modifier _isTradable(address _from, uint256 _bookID) {
        if(_from != owner){
            require(bookID[_bookID].isTradable == true, "Trading disabled");
        }
        else _;
    }

    /**
     * @dev Checks if user owns book _bookID.
     *
     * Modifier and function are included for this functionality. Dapp can call the ownsToken()
     * function to verify that a user owns a particular token before it proceeds to retrieve,
     * decrypt, and display the content.
     */
    modifier _ownsBook(uint256 _bookID, address _owner) {
        require(balanceOf(_owner, _bookID) != 0, "User does not own book");
        _;
    }

    function ownsToken(uint256 _bookID, address _owner) public view returns (bool hasToken) {
        if (balanceOf(msg.sender, _bookID) != 0) {
            hasToken = true;
        }
    }

    /**
     * @dev Function to toggle secondary trading for book _bookID.
     * 
     * The require() statement prevents spending gas to change nothing, but is
     * not necessary since these functions will be called by the dapp. Still
     * including it for now, and we can decide whether or not to keep it based
     * on the gas cost of running the check.
     */
    function toggleTrading(uint256 _bookID, bool _isTradable) external onlyOwner {
        require(bookID[_bookID].isTradable != _isTradable); //Can we save gas deleting this?
        bookID[_bookID].isTradable = _isTradable;
    }    

    /**
     * @dev See {IERC165-supportsInterface}.
     * 
     * @dev PHOENIX: Consider overwriting this to require NFT markets implement 
     * our token standard for private content NFTs. That could be
     * used to secure the royalty payments as well as adding more interventionary
     * functions to combat piracy and illegal reproduction of IP, such as the
     * ability for a Chainlink node to verify if an author actually owns the
     * copyright license for a book in dispute.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IERC1155).interfaceId
            || interfaceId == type(IERC1155MetadataURI).interfaceId
            || super.supportsInterface(interfaceId);
    }

    /**
     * @dev This implementation returns the URI stored for any _bookID,
     * overwrites ERC1155's uri() function while maintaining compatibility
     * with OpenSea's standards.
     *
     * View function costs no gas (for user), so we can introduce logic if we need it.
     *
     * One way to improve gas efficiency as mentioned above is to store book URIs as bytes32 data types, then
     * use BytesToString contract to convert back to string before passing data to the dapp.
     */
    function uri(uint256 _bookID) public view virtual override returns (string memory) {
        return _uri[_bookID];
    }

    /**
     * @dev See {IERC1155-balanceOf}.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), "ERC1155: balance query for the zero address");
        return _balances[id][account];
    }

    /**
     * @dev See {IERC1155-balanceOfBatch}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(
        address[] memory accounts,
        uint256[] memory ids
    )
        public
        view
        virtual
        override
        returns (uint256[] memory)
    {
        require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");

        uint256[] memory batchBalances = new uint256[](accounts.length);

        for (uint256 i = 0; i < accounts.length; ++i) {
            batchBalances[i] = balanceOf(accounts[i], ids[i]);
        }

        return batchBalances;
    }

    /**
     * @dev See {IERC1155-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(_msgSender() != operator, "ERC1155: setting approval status for self");

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC1155-isApprovedForAll}.
     */
    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[account][operator];
    }

    /**
     * @dev See {IERC1155-safeTransferFrom}.
     *
     * @dev PHOENIX: Added _isTradable(id) modifier to check if the book being
     * transferred is actually tradable, and if not then transaction will revert.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    )
        public
        virtual
        override
        _isTradable(id)
    {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            "ERC1155: caller is not owner nor approved"
        );
        _safeTransferFrom(from, to, id, amount, data);
    }

    /**
     * @dev See {IERC1155-safeBatchTransferFrom}.
     *
     * @dev PHOENIX: Added _isTradable(id) modifier to check if the book being
     * transferred is actually tradable, and if not then the transaction will revert.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    )
        public
        virtual
        override
        _isTradable(id)
    {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            "ERC1155: transfer caller is not owner nor approved"
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function _safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    )
        internal
        virtual
    {
        require(to != address(0), "ERC1155: transfer to the zero address");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);

        uint256 fromBalance = _balances[id][from];
        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");
        _balances[id][from] = fromBalance - amount;
        _balances[id][to] += amount;

        emit TransferSingle(operator, from, to, id, amount);

        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function _safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    )
        internal
        virtual
    {
        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");
        require(to != address(0), "ERC1155: transfer to the zero address");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, to, ids, amounts, data);

        for (uint256 i = 0; i < ids.length; ++i) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];

            uint256 fromBalance = _balances[id][from];
            require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");
            _balances[id][from] = fromBalance - amount;
            _balances[id][to] += amount;
        }

        emit TransferBatch(operator, from, to, ids, amounts);

        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);
    }

    /**
     * @dev Sets a new URI for each _bookID metadata. Overwrites ERC1155's _setURI()
     * function to implement mapping each token's ID to a unique IPFS URI. This
     * URI links to the JSON metadata file, which in turn holds the location of the
     * encrypted content.
     *
     * _setURI checks that the URI passed to it isn't an empty string.
     *
     * GAS OPTIMIZATION IDEA:
     * Try storing all URIs as bytes32, then using BytesToString contract to
     * convert from bytes back to string again when calling uri(). Since uri()
     * is view only, this operation should cost no gas to perform, and since
     * bytes32 require less space than strings the _setURI() function should
     * take less gas to run as well.
     */

    function setURI(string memory newURI, uint256 _bookID) external onlyOwner {
        _setURI(newURI, _bookID);
    }

    function _setURI(string memory newuri, uint256 _bookID) internal virtual {
        _uri[_bookID] = newuri;
        bytes memory tempString = bytes(_uri[_bookID]);
        assert(tempString.length != 0);
    }

    /**
     * @dev Publishes and mints a new NFT ebook.
     * @param _newURI IPFS URI of ebook's metadata
     * @param _royalty % of each sale that is sent back to author
     * @param _isTradable True: Book can be resold to other readers
     * @param _isMintable True: Author can mint more copies
     * @param _amount Amount of copies to be minted at creation
     *
     * If author selects false for _isMintable, then books will begin with
     * capped supply and a disabled mint function.
     *
     */
     function publishBook(
         string memory _newURI,
         address _royaltyAddress, 
         uint8 _royaltyPercent, 
         bool _isTradable, 
         bool _isMintable,
         uint256 _amount)
         external
         onlyOwner
         returns (bool) {
            require(_amount > 0, "Cannot mint 0");
            require(_royalty <= 100, "Cannot take more than 100%");

            Book memory newBook = new Book(
                _royaltyAddress, 
                _isMintable, 
                _isTradable, 
                _royaltyPercent);
            bookID[bookIDCounter] = newBook;

            _setURI(_newURI, bookIDCounter);
            require(_mint(msg.sender, bookIDCounter, _amount), "Minting failed");

            bookIDCounter++;
            return true;
         }

     /**
      * @dev Mints more copies of a published book.
      *
      * Has onlyOwner and _isMintable modifiers. Only the contract owner of the contract can call these functions,
      * and the book has to be mintable as well. Books that are limited edition with capped supplies are not
      * mintable, which is enforced by the _isMintable modifier.
      */

    function mintBooks(uint256 _bookID, uint256 _amount) external onlyOwner _isMintable(_bookID) returns (bool) {
        require(_mint(msg.sender, _bookID, _amount), "Minting failed");
    }

    function batchMintBooks(uint256[] _bookIDs, uint256[] _amounts) external onlyOwner _isMintable(_bookID) returns (bool) {
        _mintBatch(msg.sender, _bookIDs, _amounts, "");
    }

    /**
     * @dev Permanently removes a book from publication, making it un-mintable.
     *
     * THIS SHOULD BE AN OPTIONAL FEATURE TO BE SELECTED WHEN AN AUTHOR CREATES THEIR CONTRACT
     *
     * The primary use case of these functions is to make a particular copy of a book a special edition copy after
     * it has been in circulation. If a particular book becomes very popular, then the author can opt to unpublish
     * it so its value increases. This function is meant for an author to lock themself out of the mint function,
     * which removes trust from the scarcity of an NFT ebook.
     */

     function unpublishBook(uint256 _bookID) external onlyOwner isMintable(_bookID) returns (bool) {
         bookID[_bookID].isMintable = false;
     }

     function batchUnpublishBooks(uint256[] _bookIDs) external onlyOwner isMintable(_bookID) returns (bool) {
         for (uint256 i = 0; i <_bookIDs.length; i++){
             bookID[_bookIDs[i]].isMintable = false;
         }
     }

     /**
     * @dev Burns copies of a book, permanently removing it from circulation.
     *
     * A use case for a burn function is if an author's NFT ebook supply is too high and they want to reduce
     * the circulating supply. Also provides the option for buying books back in order to burn them, which could
     * be useful for early edition NFT ebooks that have become valuable over time, or books that were illegally
     * published and minted on the platform. The dapp can be set up to pay a reader the mint price of a book
     * that is flagged as pirated, while also not displaying the book in the view window.
     */

     function burn(uint256 _bookID, uint256 _amount) external returns (bool) {
         _burn(msg,sender, _bookID, _amount);
     }

     function burnBatch(uint256[] _bookIDs, uint256[] _amounts) external returns (bool) {
        _burnBatch(msg.sender, _bookIDs, amounts);
     }

     /**
      * @dev Toggles whether a book is tradable by readers or not.
      *
      * THIS SHOULD BE OPTIONAL WHEN AUTHOR CREATES CONTRACT
      * 
      * I'm including both a single and a batch function, and we can decide if we want to keep the single. Batch
      * function is convenient for toggling more than one book, but single toggle will likely be less expensive 
      * than the batch toggle for a single token.
      *
      * A use case for batch toggling of trading is if an author isn't comfortable having their books up for trade
      * 24/7 and want to only allow trading for limited periods of time.
      */

    function toggleTrading(uint256 _bookID) external onlyOwner returns (bool) {
        if(bookID[_bookID].isTradable) {
            bookID[_bookID].isTradable = false;
        }
        else bookID[_bookID].isTradable = true;
        return true;
    }

    function batchToggleTrading(uint256[] _bookIDs) external onlyOwner returns (bool) {
        for (uint256 i = 0; i < _bookIDs.length; i++){
            Book memory selectedBook = bookID[_bookIDs[i]];
            if(selectedBook.isTradable) {
                selectedBook.isTradable = false;
            }
            else selectedBook.isTradable = true;            
        }
        return true;
    }

    /**
     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual returns (bool) {
        require(account != address(0), "ERC1155: mint to the zero address");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);

        _balances[id][account] += amount;
        emit TransferSingle(operator, address(0), account, id, amount);

        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);
        return true;
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual returns (bool) {
        require(to != address(0), "ERC1155: mint to the zero address");
        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);

        for (uint i = 0; i < ids.length; i++) {
            _balances[ids[i]][to] += amounts[i];
        }

        emit TransferBatch(operator, address(0), to, ids, amounts);

        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);
        return true;
    }

    /**
     * @dev Destroys `amount` tokens of token type `id` from `account`
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens of token type `id`.
     */
    function _burn(address account, uint256 id, uint256 amount) internal virtual returns (bool) {
        require(account != address(0), "ERC1155: burn from the zero address");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), "");

        uint256 accountBalance = _balances[id][account];
        require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");
        _balances[id][account] = accountBalance - amount;

        emit TransferSingle(operator, account, address(0), id, amount);
        return true;
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     */
    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual returns (bool) {
        require(account != address(0), "ERC1155: burn from the zero address");
        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, account, address(0), ids, amounts, "");

        for (uint i = 0; i < ids.length; i++) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];

            uint256 accountBalance = _balances[id][account];
            require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");
            _balances[id][account] = accountBalance - amount;
        }

        emit TransferBatch(operator, account, address(0), ids, amounts);
        return true;
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning, as well as batched variants.
     *
     * The same hook is called on both single and batched variants. For single
     * transfers, the length of the `id` and `amount` arrays will be 1.
     *
     * Calling conditions (for each `id` and `amount` pair):
     *
     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * of token type `id` will be  transferred to `to`.
     * - When `from` is zero, `amount` tokens of token type `id` will be minted
     * for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`
     * will be burned.
     * - `from` and `to` are never both zero.
     * - `ids` and `amounts` have the same, non-zero length.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    )
        internal
        virtual
    { }

    function _doSafeTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    )
        private
    {
        if (to.isContract()) {
            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {
                if (response != IERC1155Receiver(to).onERC1155Received.selector) {
                    revert("ERC1155: ERC1155Receiver rejected tokens");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert("ERC1155: transfer to non ERC1155Receiver implementer");
            }
        }
    }

    function _doSafeBatchTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    )
        private
    {
        if (to.isContract()) {
            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {
                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {
                    revert("ERC1155: ERC1155Receiver rejected tokens");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert("ERC1155: transfer to non ERC1155Receiver implementer");
            }
        }
    }

    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {
        uint256[] memory array = new uint256[](1);
        array[0] = element;

        return array;
    }
}








